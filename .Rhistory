consumo_tslm <- tslm(treino_tslm ~ season + trend + I(trend^2))
summary(consumo_tslm)
checkresiduals(consumo_tslm)
autoplot(fc_tslm)
fc_tslm <- forecast(consumo_tslm, h =12)
autoplot(fc_tslm)
teste_tslm <- consumo_split$test
test_forecast(ts_consumo,
forecast.obj = fc_tslm,
test = teste_tslm)
accuracy(fc_tslm, teste_tslm)
treino_ets <- consumo_split$train
teste_ets <- consumo_split$test
consumo_ets <- ets(treino_ets)
summary(consumo_ets)
fc_ets <- forecast(consumo_ets, h =12)
accuracy(fc_ets)
test_forecast(ts_consumo,
forecast.obj = fc_ets,
test = teste_ets)
accuracy(fc_ets, teste_ets)
accuracy(fc_HW_grid, teste_HW)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
accuracy(fc_consumo_snaive, teste_snaive)
accuracy(fc_tslm, teste_tslm)
accuracy(fc_ets, teste_ets)
test_forecast(ts_consumo,
forecast.obj = fc_tslm,
test = teste_tslm,
title = "ETS")
hw <- accuracy(fc_HW_grid, teste_HW)
SES <- accuracy(fc_consumo_SES, teste_SES)
arima <- accuracy(fc_consumo_ARIMA, teste_ARIMA)
snaive <- accuracy(fc_consumo_snaive, teste_snaive)
tslm <- accuracy(fc_tslm, teste_tslm)
ets <- accuracy(fc_ets, teste_ets)
hw
ggplot() +
geom_boxplot(aes(x = hw))
fc_consumo_ARIMA
accuracy(fc_HW_grid, teste_HW)
plot_error(fc_consumo_ARIMA, error = "MAPE", palette = "Set1")
md <- train_model(input = ts_consumo,
methods = auto.arima,
train_method = list(partitions = 4,
sample.out = 12,
space = 3),
horizon = 12,
error = "MAPE")
plot_error(md)
methods <- list(ets = list(method = "ets",
method_arg = list(opt.crit = "lik"),
notes = "ETS model with opt.crit = lik"),
arima = list(method = "arima",
method_arg = list(order = c(1,1,1),
seasonal = list(order = c(0,1,1))),
notes = "SARIMA(1,1,1)(0,1,1)"),
hw = list(method = "HoltWinters",
method_arg = NULL,
notes = "HoltWinters Model"),
tslm = list(method = "tslm",
method_arg = list(formula = input ~ trend + season),
notes = "tslm model with trend and seasonal components"))
md <- train_model(input = ts_consumo,
methods = methods,
train_method = list(partitions = 4,
sample.out = 12,
space = 3),
horizon = 12,
error = "MAPE")
plot_error(md)
accuracy(fc_HW_grid, teste_HW)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
accuracy(fc_consumo_snaive, teste_snaive)
accuracy(fc_tslm, teste_tslm)
accuracy(fc_ets, teste_ets)
test_forecast(ts_consumo,
forecast.obj = fc_consumo_ARIMA,
test = teste_ARIMA)
plot_forecast(fc_HW_grid,
title = "Consumo de energia elétrica do Sudeste",
Ytitle = "Consumo (MWh)",
Xtitle = "Ano"
)
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW_grid,
test = teste_HW)
consumo_rn <- nnetar(ts_consumo)
treino_rn <- consumo_split$train
teste_rn <- consumo_split$test
consumo_rn <- nnetar(ts_consumo)
summary(consumo_rn)
consumo_rn
fc_rn <- forecast(consumo_rn, h = 12)
accuracy(fc_rn, teste_rn)
fc_rn <- forecast(consumo_rn, h = 12)
accuracy(fc_rn, teste_rn)
consumo_rn <- nnetar(treino_rn)
summary(consumo_rn)
fc_rn <- forecast(consumo_rn, h = 12)
accuracy(fc_rn, teste_rn)
test_forecast(ts_consumo,
forecast.obj = fc_rn,
test = teste_rn)
autoplot(fc_rn)
consumo_rn
consumo_rn
accuracy(fc_HW_grid, teste_HW)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
accuracy(fc_consumo_snaive, teste_snaive)
accuracy(fc_tslm, teste_tslm)
accuracy(fc_ets, teste_ets)
accuracy(fc_rn, teste_rn)
test_forecast(ts_consumo,
forecast.obj = fc_rn,
test = teste_rn)
pacotes <- c("readr","readxl","plotly","tidyverse","gridExtra","forecast","TTR",
"smooth", "tsibble", "fable","tsibbledata", "fpp3","lubridate",
"urca", "dygraphs", "quantmod","BETS","tseries","FinTS",
"gridExtra", "scales", "caret","xtable", "tsutils","GetBCBData",
"quantmod","dgof","seasonal", "forecast", "TSstudio")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
options(scipen = 999)
ggplotly(
consumo %>%
mutate(Data = as.Date(Data)) %>%
ggplot() +
geom_line(aes(x = Data, y = consumo$`Consumo(MWh)`, color = "série")) +
scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.4),
panel.background = element_rect(fill = "white", color = "black"),
panel.grid = element_line(color = "grey90"),
panel.border = element_rect(color = "black", fill = NA),
legend.position = "none")
)
ts_consumo <- ts(consumo[,2], start = c(2004,1), frequency = 12)
ts_consumo
plot(ts_consumo)
ggplotly(
consumo %>%
mutate(Data = as.Date(Data)) %>%
ggplot() +
geom_line(aes(x = Data, y = consumo$`Consumo(MWh)`, color = "série")) +
scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.4),
panel.background = element_rect(fill = "white", color = "black"),
panel.grid = element_line(color = "grey90"),
panel.border = element_rect(color = "black", fill = NA),
legend.position = "none")
)
plot(ts_consumo) %>% scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year")
plot(ts_consumo) %>% scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year")
plot(ts_consumo) %>%
# Decomposição da série temporal:
dec_ts <- decompose(ts_consumo, type = "additive")
autoplot(dec_ts)
ndiffs(ts_consumo) # Somente 1 diferenciação é necessário para que a série fique estacionária
diff_ts_consumo <- diff(ts_consumo)
ggtsdisplay(diff_ts_consumo)
ggtsdisplay(diff_ts_consumo)
ggtsdisplay(diff_ts_consumo)
consumo_split <- ts_split(ts_consumo, 12) # dividir a série em treino e teste
consumo_split
treino_HW <- consumo_split$train
teste_HW <-consumo_split$test
autoplot(ts_consumo) +
autolayer(treino_HW, series = "Treino") +
autolayer(teste_HW, series = "Teste") +
scale_color_viridis_d() +
theme_bw()
consumo_HW          # alpha: 0,76, beta: 0, gamma: 0,82
consumo_split
consumo_HW <- HoltWinters(treino_HW)
consumo_HW          # alpha: 0,76, beta: 0, gamma: 0,82
fc_HW <- forecast(consumo_HW, 12)
accuracy(fc_HW, teste_HW)         # MAPE
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW,
test = teste_HW)
ggtsdisplay(diff(treino_HW))
checkresiduals(consumo_HW)
ggtsdisplay(diff(treino_HW))
checkresiduals(consumo_HW)
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW,
test = teste_HW)
shallow_grid$grid_df[1:10,]
plot_grid(shallow_grid)
plot_grid(deep_grid)  # Nota-se que o alcance do erro dos 10% dos modelos caiu
consumo_HW_grid <- HoltWinters(treino_HW,
alpha = deep_grid$alpha,
beta = deep_grid$beta,
gamma = deep_grid$gamma)
fc_HW_grid <- forecast(consumo_HW_grid, h= 12)
accuracy(fc_HW_grid, teste_HW)
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW_grid,
test = teste_HW)
plot_forecast(fc_HW_grid,
title = "Consumo de energia elétrica do Sudeste",
Ytitle = "Consumo (MWh)",
Xtitle = "Ano"
)
plot_forecast(fc_HW_grid,
title = "Consumo de energia elétrica do Sudeste",
Ytitle = "Consumo (MWh)",
Xtitle = "Ano"
)
treino_SES <- consumo_split$train
teste_SES <- consumo_split$test
fc_consumo_SES <- ses(treino_SES, h = 12, initial = "optimal")
fc_consumo_SES$model
accuracy(fc_consumo_SES, teste_SES)
fc_consumo_SES$model
accuracy(fc_consumo_SES, teste_SES)
test_forecast(actual = ts_consumo,
forecast.obj = fc_consumo_SES,
test = teste_SES)
plot_forecast(fc_consumo_SES) %>%
add_lines(x = time(teste_SES) + deltat(teste_SES),
y = as.numeric(teste_SES),
name = "Partição de teste") %>%
layout(title = "Consumo de energia elétrica (MWh)",
xaxis = list(range = c(2004, max(time(ts_consumo)) +
deltat(ts_consumo))),
yaxis = list(range = c(10000000,25000000)))
par(mfrow=c(1,2))
acf(ts_consumo)
pacf(ts_consumo)
par(mfrow=c(1,2))
acf(ts_consumo)
pacf(ts_consumo , lag.max = 24)
treino_ARIMA <- consumo_split$train
teste_ARIMA <- consumo_split$test
consumo_ARIMA <- auto.arima(treino_ARIMA,
d=1,
D=1,
stepwise = FALSE,
approximation = FALSE,
trace = TRUE)
consumo_ARIMA
checkresiduals(consumo_ARIMA)
consumo_ARIMA
consumo_ARIMA
checkresiduals(consumo_ARIMA)
fc_consumo_ARIMA <- forecast(consumo_ARIMA, h = 12)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
test_forecast(ts_consumo,
forecast.obj = fc_consumo_ARIMA,
test = teste_ARIMA)
autoplot(fc_consumo_ARIMA)
test_forecast(ts_consumo,
forecast.obj = fc_consumo_ARIMA,
test = teste_ARIMA)
accuracy(fc_HW_grid, teste_HW)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
accuracy(fc_consumo_snaive, teste_snaive)
accuracy(fc_tslm, teste_tslm)
accuracy(fc_ets, teste_ets)
accuracy(fc_rn, teste_rn)
treino_tslm <- consumo_split$train
teste_tslm <- consumo_split$test
consumo_tslm <- tslm(treino_tslm ~ season + trend + I(trend^2))
summary(consumo_tslm)
checkresiduals(consumo_tslm)
accuracy(fc_tslm, teste_tslm)
test_forecast(ts_consumo,
forecast.obj = fc_tslm,
test = teste_tslm)
treino_ets <- consumo_split$train
teste_ets <- consumo_split$test
consumo_ets <- ets(treino_ets)
summary(consumo_ets)
accuracy(fc_ets, teste_ets)
test_forecast(ts_consumo,
forecast.obj = fc_ets,
test = teste_ets)
treino_rn <- consumo_split$train
teste_rn <- consumo_split$test
consumo_rn <- nnetar(treino_rn)    #NNAR(2,1,2)[12]
consumo_rn
summary(consumo_rn)
accuracy(fc_rn, teste_rn)
test_forecast(ts_consumo,
forecast.obj = fc_rn,
test = teste_rn)
ggplotly(
consumo %>%
mutate(Data = as.Date(Data)) %>%
ggplot() +
geom_line(aes(x = Data, y = consumo$`Consumo(MWh)`, color = "série")) +
scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.4),
panel.background = element_rect(fill = "white", color = "black"),
panel.grid = element_line(color = "grey90"),
panel.border = element_rect(color = "black", fill = NA),
legend.position = "none")
)
accuracy(fc_HW_grid, teste_HW)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
accuracy(fc_tslm, teste_tslm)
accuracy(fc_ets, teste_ets)
accuracy(fc_rn, teste_rn)
pacotes <- c("readr","readxl","plotly","tidyverse","gridExtra","forecast","TTR",
"smooth", "tsibble", "fable","tsibbledata", "fpp3","lubridate",
"urca", "dygraphs", "quantmod","BETS","tseries","FinTS",
"gridExtra", "scales", "caret","xtable", "tsutils","GetBCBData",
"quantmod","dgof","seasonal", "forecast", "TSstudio")
pacotes <- c("readr","readxl","plotly","tidyverse","gridExtra","forecast","TTR",
"smooth", "tsibble", "fable","tsibbledata", "fpp3","lubridate",
"urca", "dygraphs", "quantmod","BETS","tseries","FinTS",
"gridExtra", "scales", "caret","xtable", "tsutils","GetBCBData",
"quantmod","dgof","seasonal", "forecast", "TSstudio")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
options(scipen = 999)
consumo <- read_excel("/Users/guilh/OneDrive/Área de Trabalho/TCC/consumo_de_energia.xlsx")
View(consumo)
ggplotly(
consumo %>%
mutate(Data = as.Date(Data)) %>%
ggplot() +
geom_line(aes(x = Data, y = consumo$`Consumo(MWh)`, color = "série")) +
scale_color_viridis_d() +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.4),
panel.background = element_rect(fill = "white", color = "black"),
panel.grid = element_line(color = "grey90"),
panel.border = element_rect(color = "black", fill = NA),
legend.position = "none")
)
ts_consumo <- ts(consumo[,2], start = c(2004,1), frequency = 12)
ts_consumo
plot(ts_consumo) %>%
# Decomposição da série temporal:
dec_ts <- decompose(ts_consumo, type = "additive")
autoplot(dec_ts)
ndiffs(ts_consumo) # Somente 1 diferenciação é necessário para que a série fique estacionária
diff_ts_consumo <- diff(ts_consumo)
ggtsdisplay(diff_ts_consumo)
length(ts_consumo)
0.7*length(ts_consumo)   # 70% da base original são as primeiras 155 observações.
consumo_split <- ts_split(ts_consumo, 12) # dividir a série em treino e teste
consumo_split
treino_HW <- consumo_split$train
teste_HW <-consumo_split$test
autoplot(ts_consumo) +
autolayer(treino_HW, series = "Treino") +
autolayer(teste_HW, series = "Teste") +
scale_color_viridis_d() +
theme_bw()
consumo_HW <- HoltWinters(treino_HW)
consumo_HW          # alpha: 0,76, beta: 0, gamma: 0,82
fc_HW <- forecast(consumo_HW, 12)
accuracy(fc_HW, teste_HW)         # MAPE
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW,
test = teste_HW)
ggtsdisplay(diff(treino_HW))
checkresiduals(consumo_HW)
par(mfrow=c(2,2))
plot(resid(consumo_HW))
qqnorm(resid(consumo_HW))
acf(resid(consumo_HW))
pacf(resid(consumo_HW))
par(mfrow=c(1,1))
shallow_grid <- ts_grid(treino_HW,
model = "HoltWinters",
periods = 6,
window_space = 6,
window_test = 12,
hyper_params = list(alpha = seq(0,1,0.1),
beta = seq(0,1,0.1),
gamma = seq(0,1,0.1)),
parallel = TRUE,
n.cores = 8
)
shallow_grid$grid_df[1:10,]
shallow_grid$grid_df[1:10,]
plot_grid(shallow_grid)
deep_grid <- ts_grid(treino_HW,
model = "HoltWinters",
periods = 6,
window_space = 6,
window_test = 12,
hyper_params = list(alpha = seq(0.1,0.2,0.01),
beta = seq(0,0.2,0.01),
gamma = seq(0.3,0.9,0.01)),
parallel = TRUE,
n.cores = 8)
plot_grid(deep_grid)  # Nota-se que o alcance do erro dos 10% dos modelos caiu
consumo_HW_grid <- HoltWinters(treino_HW,
alpha = deep_grid$alpha,
beta = deep_grid$beta,
gamma = deep_grid$gamma)
fc_HW_grid <- forecast(consumo_HW_grid, h= 12)
accuracy(fc_HW_grid, teste_HW)
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW_grid,
test = teste_HW)
plot_forecast(fc_HW_grid,
title = "Consumo de energia elétrica do Sudeste",
Ytitle = "Consumo (MWh)",
Xtitle = "Ano"
)
consumo_HW_grid <- HoltWinters(treino_HW,
alpha = deep_grid$alpha,
beta = deep_grid$beta,
gamma = deep_grid$gamma)
fc_HW_grid <- forecast(consumo_HW_grid, h= 12)
accuracy(fc_HW_grid, teste_HW)
test_forecast(actual = ts_consumo,
forecast.obj = fc_HW_grid,
test = teste_HW)
accuracy(fc_HW_grid, teste_HW)
treino_SES <- consumo_split$train
teste_SES <- consumo_split$test
fc_consumo_SES <- ses(treino_SES, h = 12, initial = "optimal")
fc_consumo_SES$model
accuracy(fc_consumo_SES, teste_SES)
ggtsdisplay(diff(treino_SES))
checkresiduals(fc_consumo_SES)
par(mfrow=c(2,2))
plot(resid(fc_consumo_SES))
qqnorm(resid(fc_consumo_SES))
acf(resid(fc_consumo_SES))
pacf(resid(fc_consumo_SES))
par(mfrow=c(1,1))
test_forecast(actual = ts_consumo,
forecast.obj = fc_consumo_SES,
test = teste_SES)
accuracy(fc_consumo_SES, teste_SES)
accuracy(fc_consumo_SES, teste_SES)
treino_ARIMA <- consumo_split$train
teste_ARIMA <- consumo_split$test
consumo_ARIMA <- auto.arima(treino_ARIMA,
d=1,
D=1,
stepwise = FALSE,
approximation = FALSE,
trace = TRUE)
consumo_ARIMA
checkresiduals(consumo_ARIMA)
fc_consumo_ARIMA <- forecast(consumo_ARIMA, h = 12)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
test_forecast(ts_consumo,
forecast.obj = fc_consumo_ARIMA,
test = teste_ARIMA)
autoplot(fc_consumo_ARIMA)
fc_consumo_ARIMA_h48 <- forecast(consumo_ARIMA, h = 48)
autoplot(fc_consumo_ARIMA_h48)
ArchTest(fc_consumo_ARIMA$residuals)
checkresiduals(consumo_ARIMA)
accuracy(fc_consumo_ARIMA, teste_ARIMA)
treino_tslm <- consumo_split$train
teste_tslm <- consumo_split$test
consumo_tslm <- tslm(treino_tslm ~ season + trend + I(trend^2))
summary(consumo_tslm)
checkresiduals(consumo_tslm)
fc_tslm <- forecast(consumo_tslm, h =12)
autoplot(fc_tslm)
test_forecast(ts_consumo,
forecast.obj = fc_tslm,
test = teste_tslm)
accuracy(fc_tslm, teste_tslm)
treino_ets <- consumo_split$train
teste_ets <- consumo_split$test
consumo_ets <- ets(treino_ets)
summary(consumo_ets)
fc_ets <- forecast(consumo_ets, h =12)
accuracy(fc_ets, teste_ets)
summary(consumo_ets)
accuracy(fc_ets, teste_ets)
treino_rn <- consumo_split$train
teste_rn <- consumo_split$test
consumo_rn <- nnetar(treino_rn)    #NNAR(2,1,2)[12]
consumo_rn
summary(consumo_rn)
fc_rn <- forecast(consumo_rn, h = 12)
autoplot(fc_rn)
accuracy(fc_rn, teste_rn)
test_forecast(ts_consumo,
forecast.obj = fc_rn,
test = teste_rn)
consumo_rn
accuracy(fc_rn, teste_rn)
source("C:/Users/guilh/OneDrive/Área de Trabalho/DATA SCIENCE/TCC/TCC/TCC-final.R", encoding = 'UTF-8')
